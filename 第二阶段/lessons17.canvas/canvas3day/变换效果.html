<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        body {
            text-align: center;
        }

        canvas {
            box-shadow: 0 0 20px rgb(145, 167, 144);
        }
    </style>
</head>

<body>
    <canvas id="canvas" width="700" height="600"></canvas>
</body>
<script>
    var cv = document.getElementById('canvas');
    var ctx = cv.getContext('2d');

    // ctx.fillRect(0, 0, 100, 100)
    //canvas的变换效果：ｃａｎｖａｓ中的所有类型的变换你效果都是对画布坐标系产生影响
    //translate ：平移变换
    // ctx.translate(100, 100); //将画布坐标系原点平移
    // ctx.fillRect(0, 0, 100, 100)
    //
    //save() && restore();
    /**
    ctx.fillStyle = 'yellow';
    ctx.fillRect(100, 100, 100, 100)
    //
    // 记录初始坐标系原地坐标
    var x = 0,
        y = 0;

    function animate() { console.log(x) x += 5; if (x >= 500) { x = 500 }
    cv.width = cv.width; ctx.translate(x, y); ctx.fillRect(0, 0, 100, 100)
    requestAnimationFrame(animate)

    } // window.requestAnimationFrame(animate) // setInterval(animate, 30); //
    requestAnimationFrame();以递归的方式重复执行动画函数，自动确定动画的帧 // cancelAnimationFrame();
    // // 旋转变换 // 缩放变换  scale(x,y)

    var d = Math.PI / 180;
    ctx.translate(cv.width / 2, cv.height / 2);
    for (var i = 0; i < 18; i++) {
        ctx.arc(0, 0, 100, 0, Math.PI * 2);
        ctx.stroke()
        ctx.scale(1.1, 1.1);
        ctx.rotate(20 * d);
        ctx.translate(0, 10)
    }
    **/
    for (var i = 0; i < 18; i++) {
        ctx.fillRect(10, 10, 10, 10)
        ctx.scale(1.2, 1.2);

    }
</script>

</html>